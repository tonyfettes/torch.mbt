// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!

pub fn wasmExportLoad(p0 : Int, p1 : Int) -> Unit {
  let result = @ffi.ptr2str(p0, p1)
  let _ = @mnist.load(result)

}

pub fn wasmExportSave() -> Int {
  let result : String = @mnist.save()
  @ffi.store32(return_area + 4, result.iter().count())
  @ffi.store32(return_area + 0, @ffi.str2ptr(result))
  return return_area
}

pub fn wasmExportSavePostReturn(p0 : Int) -> Unit {
  @ffi.free(@ffi.load32(p0 + 0))
}

pub fn wasmExportInfer(p0 : Int, p1 : Int) -> Int {
  let result = @ffi.ptr2float_array(p0, p1)
  let result0 : FixedArray[Float] = @mnist.infer(result)
  @ffi.store32(return_area + 4, result0.length())
  @ffi.store32(return_area + 0, @ffi.float_array2ptr(result0))
  return return_area
}

pub fn wasmExportInferPostReturn(p0 : Int) -> Unit {
  @ffi.free(@ffi.load32(p0 + 0))
}

pub fn wasmExportTrain(p0 : Int, p1 : Int, p2 : Float) -> Float {
  let array : FixedArray[(FixedArray[Float], Int)] = FixedArray::make(
    p1,
    ([], 0),
  )
  for index = 0; index < p1; index = index + 1 {
    let base = p0 + index * 12
    let result = @ffi.ptr2float_array(
      @ffi.load32(base + 0),
      @ffi.load32(base + 4),
    )
    array[index] = (result, @ffi.load32(base + 8))
  }
  @ffi.free(p0)
  let result0 : Float = @mnist.train(array, p2)
  return result0
}
