// Generated by `wit-bindgen` 0.32.0. DO NOT EDIT!

pub extern "wasm" fn extend16(value : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.extend16_s)

pub extern "wasm" fn extend8(value : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.extend8_s)

pub extern "wasm" fn store8(offset : Int, value : Int) =
  #|(func (param i32) (param i32) local.get 0 local.get 1 i32.store8)

pub extern "wasm" fn load8_u(offset : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.load8_u)

pub extern "wasm" fn load8(offset : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.load8_s)

pub extern "wasm" fn store16(offset : Int, value : Int) =
  #|(func (param i32) (param i32) local.get 0 local.get 1 i32.store16)

pub extern "wasm" fn load16(offset : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.load16_s)

pub extern "wasm" fn load16_u(offset : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.load16_u)

pub extern "wasm" fn store32(offset : Int, value : Int) =
  #|(func (param i32) (param i32) local.get 0 local.get 1 i32.store)

pub extern "wasm" fn load32(offset : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.load)

pub extern "wasm" fn store64(offset : Int, value : Int64) =
  #|(func (param i32) (param i64) local.get 0 local.get 1 i64.store)

pub extern "wasm" fn load64(offset : Int) -> Int64 =
  #|(func (param i32) (result i64) local.get 0 i64.load)

pub extern "wasm" fn storef32(offset : Int, value : Float) =
  #|(func (param i32) (param f32) local.get 0 local.get 1 f32.store)

pub extern "wasm" fn loadf32(offset : Int) -> Float =
  #|(func (param i32) (result f32) local.get 0 f32.load)

pub extern "wasm" fn storef64(offset : Int, value : Double) =
  #|(func (param i32) (param f64) local.get 0 local.get 1 f64.store)

pub extern "wasm" fn loadf64(offset : Int) -> Double =
  #|(func (param i32) (result f64) local.get 0 f64.load)

pub extern "wasm" fn f32_to_i32(value : Float) -> Int =
  #|(func (param f32) (result i32) local.get 0 f32.convert_i32_s)

pub extern "wasm" fn f32_to_i64(value : Float) -> Int64 =
  #|(func (param f32) (result i64) local.get 0 f32.convert_i64_s)

extern "wasm" fn memory_size() -> Int =
  #|(func (result i32) memory.size)

extern "wasm" fn memory_grow(size : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 memory.grow)

struct MemoryBlock {
  addr : Int
  mut size : Int
  mut live : Bool
}

struct MemoryManager {
  blocks : Array[MemoryBlock]
}

let memory_manager : MemoryManager = MemoryManager::{
  blocks: [{ addr: 0, size: memory_size() * 65536, live: false }],
}

fn MemoryManager::grow(self : MemoryManager, size : Int) -> Int {
  let size = (size + 65535) / 65536
  let old_size = memory_grow(size)
  if old_size == -1 {
    abort("out of memory")
  }
  let block = MemoryBlock::{
    addr: old_size * 65536,
    size: size * 65536,
    live: false,
  }
  self.blocks.push(block)
  self.blocks.length() - 1
}

pub fn MemoryManager::allocate(self : MemoryManager, size : Int) -> Int {
  for i = 0; i < self.blocks.length(); i = i + 1 {
    if self.blocks[i].live {
      continue
    }
    if self.blocks[i].size < size {
      continue
    }
    if self.blocks[i].size > size {
      self.blocks.insert(
        i + 1,
        MemoryBlock::{
          addr: self.blocks[i].addr + size,
          size: self.blocks[i].size - size,
          live: false,
        },
      )
      self.blocks[i].size = size
    }
    self.blocks[i].live = true
    return self.blocks[i].addr
  }
  let i = self.grow(size)
  if self.blocks[i].size < size {
    abort("out of memory")
  }
  if self.blocks[i].size > size {
    self.blocks.push(
      MemoryBlock::{
        addr: self.blocks[i].addr + size,
        size: self.blocks[i].size - size,
        live: false,
      },
    )
    self.blocks[i].size = size
  }
  self.blocks[i].live = true
  self.blocks[i].addr
}

pub fn malloc(size : Int) -> Int {
  memory_manager.allocate(size)
}

fn MemoryManager::merge_prev(self : MemoryManager, i : Int) -> Int {
  loop i {
    0 => 0
    i => {
      if self.blocks[i - 1].live {
        return i
      }
      self.blocks[i - 1].size += self.blocks[i].size
      self.blocks.remove(i) |> ignore
      continue i - 1
    }
  }
}

fn MemoryManager::merge_next(self : MemoryManager, i : Int) -> Unit {
  while i < self.blocks.length() - 1 {
    if self.blocks[i + 1].live {
      return
    }
    self.blocks[i].size += self.blocks[i + 1].size
    self.blocks.remove(i + 1) |> ignore
  }
}

fn MemoryManager::merge(self : MemoryManager, i : Int) -> Unit {
  let i = self.merge_prev(i)
  self.merge_next(i)
}

fn MemoryManager::deallocate(self : MemoryManager, ptr : Int) -> Unit {
  for i = 0; i < self.blocks.length(); i = i + 1 {
    if self.blocks[i].addr != ptr {
      continue
    }
    if not(self.blocks[i].live) {
      abort("double free at \{ptr}")
    }
    self.blocks[i].live = false
    self.merge(i)
    return
  }
  abort("freeing unallocated memory at \{ptr}")
}

pub fn free(ptr : Int) -> Unit {
  memory_manager.deallocate(ptr)
}

fn MemoryManager::reallocate(
  self : MemoryManager,
  ptr : Int,
  size : Int
) -> Int {
  for i = 0; i < self.blocks.length(); i = i + 1 {
    if self.blocks[i].addr != ptr {
      continue
    }
    if not(self.blocks[i].live) {
      abort("reallocating freed memory at \{ptr}")
    }
    if self.blocks[i].size > size {
      self.blocks.insert(
        i + 1,
        MemoryBlock::{
          addr: self.blocks[i].addr + size,
          size: self.blocks[i].size - size,
          live: false,
        },
      )
      self.blocks[i].size = size
      return ptr
    }
    if self.blocks[i].size == size {
      return ptr
    }
    self.blocks[i].live = false
    self.merge_next(i)
    self.blocks[i].live = true
    if self.blocks[i].size > size {
      self.blocks.insert(
        i + 1,
        MemoryBlock::{
          addr: self.blocks[i].addr + size,
          size: self.blocks[i].size - size,
          live: false,
        },
      )
      self.blocks[i].size = size
      return ptr
    }
    if self.blocks[i].size == size {
      return ptr
    }
    let new_ptr = self.allocate(size)
    copy_inline(new_ptr, ptr, size)
    self.deallocate(ptr)
    return new_ptr
  }
  abort("reallocating unallocated memory at \{ptr}")
}

pub fn realloc(ptr : Int, size : Int) -> Int {
  memory_manager.reallocate(ptr, size)
}

extern "wasm" fn copy_inline(dest : Int, src : Int, len : Int) =
  #|(func (param i32) (param i32) (param i32) local.get 0 local.get 1 local.get 2 memory.copy)

pub fn ptr2str(ptr : Int, len : Int) -> String {
  let buf = Buffer::new()
  for i = 0; i < len * 2; i = i + 1 {
    buf.write_byte(load8_u(ptr + i).to_byte())
  }
  free(ptr)
  buf.to_string()
}

pub fn double_array2ptr(array : FixedArray[Double]) -> Int {
  let ptr = malloc(array.length() * 8)
  for i = 0; i < array.length(); i = i + 1 {
    storef64(ptr + i * 8, array[i])
  }
  ptr
}

pub fn ptr2double_array(ptr : Int, len : Int) -> FixedArray[Double] {
  let array = FixedArray::make(len, 0.0)
  for i = 0; i < len; i = i + 1 {
    array[i] = loadf64(ptr + i * 8)
  }
  free(ptr)
  array
}

pub trait Any {}

pub struct Cleanup {
  address : Int
  size : Int
  align : Int
}
