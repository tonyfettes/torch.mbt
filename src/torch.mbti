package tonyfettes/torch

// Values
fn normal(~mean : Double = .., ~std : Double = ..) -> Double

fn seed(Bytes) -> Unit

// Types and methods
pub struct Categorical {
  pub logits : Tensor
  pub probs : Tensor
}
impl Categorical {
  log_prob(Self, Int) -> Value
  new(Tensor) -> Self
  sample(Self) -> Int
  to_string(Self) -> String
}

pub enum Graph {
  Val
  Var
  Add(Value, Value)
  Mul(Value, Value)
  Div(Value, Value)
  Neg(Value)
  Exp(Value)
  Log(Value)
  Sum(Tensor)
  Pow(Value, Int)
}

pub struct Linear {
  pub weight : Array[Tensor]
  pub bias : Tensor
}
impl Linear {
  forward(Self, Tensor) -> Tensor
  new(Int, Int, ~weight_distribution? : Continuous, ~bias_distribution? : Continuous) -> Self
  of(Array[Tensor], Tensor) -> Self
  output(Self, Logger) -> Unit
}

pub type MSELoss
impl MSELoss {
  forward(Self, Tensor, Tensor) -> Value
  new() -> Self
  output(Self, Logger) -> Unit
}

pub struct Normal {
  pub mean : Double
  pub std : Double
}
impl Normal {
  new(~mean : Double = .., ~std : Double = ..) -> Self
  sample(Self) -> Double
}

pub type ReLU
impl ReLU {
  forward(Self, Tensor) -> Tensor
  new() -> Self
  output(Self, Logger) -> Unit
}

pub type ReLU6
impl ReLU6 {
  forward(Self, Tensor) -> Tensor
  new() -> Self
  output(Self, Logger) -> Unit
}

pub struct Sequential {
  pub modules : Array[Module]
}
impl Sequential {
  forward(Self, Tensor) -> Tensor
  new(Array[Module]) -> Self
  output(Self, Logger) -> Unit
  to_string(Self) -> String
}

pub type Softmax
impl Softmax {
  forward(Self, Tensor) -> Tensor
  new() -> Self
  output(Self, Logger) -> Unit
}

pub type Tensor Array[Value]
impl Tensor {
  iter(Self) -> Iter[Value]
  length(Self) -> Int
  map(Self, (Value) -> Value) -> Self
  op_add(Self, Self) -> Self
  op_get(Self, Int) -> Value
  op_set(Self, Int, Value) -> Unit
  op_sub(Self, Self) -> Self
  output(Self, Logger) -> Unit
  sample(Self) -> Int
  to_string(Self) -> String
  val(Array[Double]) -> Self
  var(Array[Double]) -> Self
}

pub struct Uniform {
  pub lower : Double
  pub upper : Double
}
impl Uniform {
  new(Double, Double) -> Self
  sample(Self) -> Double
}

pub struct Value {
  pub value : Double
  pub grad : Double
  // private fields
}
impl Value {
  backward(Self, Double) -> Unit
  exp(Self) -> Self
  log(Self) -> Self
  op_add(Self, Self) -> Self
  op_div(Self, Self) -> Self
  op_mul(Self, Self) -> Self
  op_neg(Self) -> Self
  op_sub(Self, Self) -> Self
  output(Self, Logger) -> Unit
  pow(Self, Int) -> Self
  sum(Tensor) -> Self
  to_debug(Self) -> String
  to_string(Self) -> String
  val(Double) -> Self
  var(Double) -> Self
}

// Type aliases

// Traits
pub trait Continuous {
  sample(Self) -> Double
}

pub trait Discrete {
  sample(Self) -> Int
}

pub trait Loss {
  forward(Self, Tensor, Tensor) -> Value
}

pub trait Module : Show {
  forward(Self, Tensor) -> Tensor
}

// Extension Methods
impl Show for Categorical

